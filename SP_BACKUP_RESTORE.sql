create PROCEDURE SP_BACKUP_RESTORE
@DIR_BKP VARCHAR(500),
@IF_BKP_RETENCAO INT,
@MOVE_TO_NEW_FOLDER INT,
@NEW_FOLDER_MDF VARCHAR(100)= NULL,
@NEW_FOLDER_LDF VARCHAR(100)= NULL
AS

SET NOCOUNT ON

--DECLARA VARIÁVEIS--
DECLARE @COUNT INT
DECLARE @BKP VARCHAR(100)
DECLARE @QUERY1 VARCHAR(MAX)
DECLARE @QUERY2 VARCHAR(MAX)
DECLARE @BKP_RETENCAO VARCHAR (100)
DECLARE @MDF VARCHAR(100)
DECLARE @LDF VARCHAR(100)

--DECLARE @DIR_BKP VARCHAR(500)
----------------------
--CONFIGURA VALORES INICIAIS
SET @COUNT = 0											-- NÃO ALTERAR
--SET @IF_BKP_RETENCAO = 0								-- "0" PARA BKPS SEM RETENÇÃO "1" PARA RETENÇÃO
--SET @MOVE_TO_NEW_FOLDER = 1								-- RESTORE COM WITH MOVE "1" SEM "0"
--SET @NEW_FOLDER_MDF = 'NOVO_LOCAL_MDF'					-- NOVO LOCAL DOS ARQUIVOS MDF
--SET @NEW_FOLDER_LDF = 'NOVO_LOCAL_LDF'					-- NOVO LOCAL DOS ARQUIVOS LDF
--SET @DIR_BKP = 'N:\MSSQL10_50.MSSQLSERVER\MSSQL\BACKUP\'-- LOCAL DOS ARQUIVOS BKP E BAK
----------------------
--CRIA TABELAS
CREATE TABLE #RESTOREFILELISTONLY
(
LOGICALNAME	NVARCHAR(128),
PHYSICALNAME	NVARCHAR(260),
TYPE	CHAR(1),
FILEGROUPNAME	NVARCHAR(128),
SIZE	NUMERIC(20,0),
MAXSIZE	NUMERIC(20,0),
FILEID	BIGINT,
CREATELSN	NUMERIC(25,0),
DROPLSN	NUMERIC(25,0) NULL,
UNIQUEID	UNIQUEIDENTIFIER,
READONLYLSN	NUMERIC(25,0) NULL,
READWRITELSN	NUMERIC(25,0) NULL,
BACKUPSIZEINBYTES	BIGINT,
SOURCEBLOCKSIZE	INT,
FILEGROUPID	INT,
LOGGROUPGUID	UNIQUEIDENTIFIER NULL,
DIFFERENTIALBASELSN	NUMERIC(25,0) NULL,
DIFFERENTIALBASEGUID	UNIQUEIDENTIFIER,
ISREADONLY	BIT,
ISPRESENT	BIT,
TDETHUMBPRINT VARBINARY(32) 
)
CREATE TABLE #T_BKPS (AI INT IDENTITY,[FILENAME] VARCHAR(100))
CREATE TABLE #BKP_LIST (AI INT IDENTITY,C1 VARCHAR(100))

----------------------
--INSERE NA TABELA TODOS OS ARQUIVOS DO DIRETÓRIO.
INSERT INTO #BKP_LIST(C1)
EXEC ('XP_CMDSHELL ''DIR '+@DIR_BKP+'''')

----------------------
--FILTRA OS DADOS
SET ROWCOUNT 7
DELETE #BKP_LIST
----------------------
--NOVO FILTRO DOS DADOS
SET ROWCOUNT 0
DELETE #BKP_LIST
WHERE C1 LIKE '%FILE(S)%' OR C1 LIKE '%DIR(S)%' OR C1 IS NULL OR C1 LIKE '%<DIR>%'
----------------------
--SELECT APENAS NOS ARQUIVOS .BKP E .BAK E OS INSERE EM OUTRA TABELA
INSERT INTO #T_BKPS ([FILENAME])
SELECT SUBSTRING(C1,37,50) FROM #BKP_LIST
WHERE C1 LIKE '%.BKP' OR C1 LIKE '%.BAK' 
select * from #T_BKPS
----------------------
--LIMPA TABELA
DELETE #BKP_LIST
SET @COUNT = (SELECT COUNT(1) FROM #T_BKPS)
--CRIA RESTORE
WHILE @COUNT > 0
BEGIN
-- SALVA NOME DO ARQUIVO PARA O RESTORE
SET @BKP = (SELECT FILENAME FROM #T_BKPS WHERE AI = @COUNT )
SET @BKP_RETENCAO = (REVERSE(SUBSTRING((REVERSE(@BKP)),21,50))+'.BKP')

--COLETA INFORMAÇÕES SOBRE O BACKUP
INSERT INTO #RESTOREFILELISTONLY
EXEC ('RESTORE FILELISTONLY FROM DISK = '''+@DIR_BKP+@BKP+'''')
SET @COUNT = @COUNT - 1
--SALVA EM VARIÁVEL OS NOMES DOS DATAFILES
SET @MDF = (SELECT LOGICALNAME FROM #RESTOREFILELISTONLY WHERE TYPE = 'D')
SET @LDF = (SELECT LOGICALNAME FROM #RESTOREFILELISTONLY WHERE TYPE = 'L')

--VALIDA SE É BACKUP COM RETENÇÃO
IF @IF_BKP_RETENCAO = 1
BEGIN

--CRIA QUERY CASO NÃO TENHA O COMANDO WITH MOVE
SET @QUERY1 = ('RESTORE DATABASE '+ REPLACE(REPLACE(@BKP_RETENCAO,'.BAK',''),'.BKP','')+ CHAR(10) +
'FROM DISK = '''+@DIR_BKP+''+@BKP+''''+CHAR(10))

--CRIA 2ª PARTE DA QUERY CASO TENHA WITH MOVE USANDO OS NOVOS LOCAIS DE LDF E MDF.
SET @QUERY2 = ('WITH MOVE '''+@MDF+''' TO '''+@NEW_FOLDER_MDF+'\'+REPLACE(REPLACE(@BKP_RETENCAO,'.BAK',''),'.BKP','')+'.MDF'','+CHAR(10)+
'MOVE '''+@LDF+''' TO '''+@NEW_FOLDER_LDF+'\'+REPLACE(REPLACE(@BKP_RETENCAO,'.BAK',''),'.BKP','')+'.LDF'','+CHAR(10)+
'STATS'+CHAR(10)+'GO'+CHAR(10))

--PRINTA NA TELA O COMANDO JÁ COM O COMANDO WITH MOVE OU SEM DEPENDENDO DA ESCOLHA DO USUÁRIO.
IF @MOVE_TO_NEW_FOLDER = 0
BEGIN
PRINT '--RESTORE DO BANCO: '+REPLACE(REPLACE(@BKP_RETENCAO,'.BAK',''),'.BKP','')+CHAR(10)+@QUERY1 + 'STATS'+CHAR(10) +'GO'+CHAR(10)
END
IF @MOVE_TO_NEW_FOLDER =1
BEGIN
PRINT '--RESTORE DO BANCO: '+REPLACE(REPLACE(@BKP_RETENCAO,'.BAK',''),'.BKP','')+CHAR(10)+@QUERY1 + @QUERY2
END

END
--VALIDA SE É BACKUP COM RETENÇÃO
IF @IF_BKP_RETENCAO = 0
BEGIN

--CRIA QUERY CASO NÃO TENHA O COMANDO WITH MOVE

SET @QUERY1 = ('RESTORE DATABASE '+ REPLACE(REPLACE(@BKP,'.BAK',''),'.BKP','')+ CHAR(10) +
'FROM DISK = '''+@DIR_BKP+''+@BKP+''''+CHAR(10))
--CRIA 2ª PARTE DA QUERY CASO TENHA WITH MOVE USANDO OS NOVOS LOCAIS DE LDF E MDF.
SET @QUERY2 = ('WITH MOVE '''+@MDF+''' TO '''+@NEW_FOLDER_MDF+'\'+@MDF+'.MDF'','+CHAR(10)+
'MOVE '''+@LDF+''' TO '''+@NEW_FOLDER_LDF+'\'+@LDF+'.LDF'','+CHAR(10)+
'STATS'+CHAR(10)+'GO'+CHAR(10))

--PRINTA NA TELA O COMANDO JÁ COM O COMANDO WITH MOVE OU SEM DEPENDENDO DA ESCOLHA DO USUÁRIO.
IF @MOVE_TO_NEW_FOLDER = 0
BEGIN
PRINT '--RESTORE DO BANCO: '+REPLACE(REPLACE(@BKP,'.BAK',''),'.BKP','')+CHAR(10)+@QUERY1 + 'WITH STATS'+CHAR(10) +'GO'+CHAR(10)
END
IF @MOVE_TO_NEW_FOLDER =1
BEGIN
PRINT '--RESTORE DO BANCO: '+REPLACE(REPLACE(@BKP,'.BAK',''),'.BKP','')+CHAR(10)+@QUERY1 + @QUERY2
END


END
--APAGA DADOS DA TABELA DO RESTORE FILELISTONLY
DELETE #RESTOREFILELISTONLY

END

--APAGA AS TABELAS TEMPORÁRIAS CRIADAS
DROP TABLE #RESTOREFILELISTONLY
DROP TABLE #T_BKPS
DROP TABLE #BKP_LIST




